[{"content":"Emm Emm\n","permalink":"https://blog.xuhui.dev/about/","summary":"Emm Emm","title":"About"},{"content":"只是瞎扯下我认为的极致开发效率, 能提升效率的前提是前端使用TS, 连TS都没有谈个单效率\n[前端 \u0026amp; 后端] 代码生成, GraphQl和Restful API 能生成的代码尽量让他生成, 谁他妈吃饱了去写那么多代码啊.\nRestful API 后端API编写的时候, Swagger应当注明返回值类型, 使用代码生成工具, 从openapi文档生成出需要到客户端请求代码. 这一条主要方便的是前端, 后端工作量不变(我他妈还真见过swagger没有返回类型的后端, 你会写个几把后端, 至于swagger跟实际对不上的, 我也无fuck说).\nGraphQL 面对各种毫无卵用的查询, 后端和前端都苦不堪言, 那么用GraphQL. 后端定义写好数据源, 后面就可以不用管啦. 前端要啥取啥, GraphQL类型支持大大滴好, 写俩GraphQL文件, 继续生成代码, 谁他妈没事写那么多代码写着玩啊?\nGraphQl和Restful API混用 Restful API一个好处是自由, 与其他内容集成也好操作, 好改动, 我觉着写操作和敏感一些的操作都通过一般的控制器来写就行了, 记录日志, 添加各种离谱操作也方便, 用id查询单个对象也用这个, 简单. 而读操作, 特指查一组数据, 各种不胜其烦的查询条件就是从这来的, 用GraphQL.\n当然, 这会产生一个问题, 两种请求混用, 生成的代码中会包含两套类型定义, 不过我觉得问题不大, 可以忽略.\n[前端: Vue] SFC 和 TSX 到了Vue3, TS支持其实已经有很大提升了, 奈何, 模板语法跟TS就是天生不对付, 用着用着你就发现不对劲了. 而TSX呢, 现在Vue3的组件库已经有很多是用TSX写的了, 但到了日常开发, 写业务的时候问题又来了, 几乎所有Vue生态都是围绕SFC来的, 用TSX就放弃了许多, 比如antfu自动引入组件的unplugin插件(当然, 用TSX也必然有收获, 比如clinyong.vscode-css-modules这个插件, 比如你可以摆脱volar给你的旧电脑减减负).\n那么我的建议是, 大部分组件使用TSX编写, 需要的组件在全局注册, 手动添加d.ts文件支持类型, 需要写大量插槽的组件使用SFC编写, 一般来说我们的组件不会出现有大量插槽的情况, 真出现了, 那说明这部分设计可能有问题了. 需要注意的是一个很尴尬的情况是TSX文件中引入SFC组件是没有正确的类型提示的, 毕竟全局的类型声明是给写死了的, 只是volar给SFC提供了特殊支持, 也就是说, 我们的SFC组件不应该有复杂的props(最好没有, 或者干脆就不被其他组件调用), 那么情况很明了了, 我们的SFC应当是某一部分的入口文件, 由于种种原因无法避免地聚合了许多组件和逻辑, 才有了一大堆该死的的插槽.\n","permalink":"https://blog.xuhui.dev/posts/ultimate-development-efficiency/","summary":"只是瞎扯下我认为的极致开发效率, 能提升效率的前提是前端使用TS, 连TS都没有谈个单效率\n[前端 \u0026amp; 后端] 代码生成, GraphQl和Restful API 能生成的代码尽量让他生成, 谁他妈吃饱了去写那么多代码啊.\nRestful API 后端API编写的时候, Swagger应当注明返回值类型, 使用代码生成工具, 从openapi文档生成出需要到客户端请求代码. 这一条主要方便的是前端, 后端工作量不变(我他妈还真见过swagger没有返回类型的后端, 你会写个几把后端, 至于swagger跟实际对不上的, 我也无fuck说).\nGraphQL 面对各种毫无卵用的查询, 后端和前端都苦不堪言, 那么用GraphQL. 后端定义写好数据源, 后面就可以不用管啦. 前端要啥取啥, GraphQL类型支持大大滴好, 写俩GraphQL文件, 继续生成代码, 谁他妈没事写那么多代码写着玩啊?\nGraphQl和Restful API混用 Restful API一个好处是自由, 与其他内容集成也好操作, 好改动, 我觉着写操作和敏感一些的操作都通过一般的控制器来写就行了, 记录日志, 添加各种离谱操作也方便, 用id查询单个对象也用这个, 简单. 而读操作, 特指查一组数据, 各种不胜其烦的查询条件就是从这来的, 用GraphQL.\n当然, 这会产生一个问题, 两种请求混用, 生成的代码中会包含两套类型定义, 不过我觉得问题不大, 可以忽略.\n[前端: Vue] SFC 和 TSX 到了Vue3, TS支持其实已经有很大提升了, 奈何, 模板语法跟TS就是天生不对付, 用着用着你就发现不对劲了. 而TSX呢, 现在Vue3的组件库已经有很多是用TSX写的了, 但到了日常开发, 写业务的时候问题又来了, 几乎所有Vue生态都是围绕SFC来的, 用TSX就放弃了许多, 比如antfu自动引入组件的unplugin插件(当然, 用TSX也必然有收获, 比如clinyong.","title":"极致的开发效率"},{"content":"在Vue3中, 函数组件得到了史诗级加强, 具体表现有二\n写法简化, 使用便利性大大增强 随处可用的h, 插槽改版, 适用范围更加宽广 因此在Vue3下, 可以看到的是函数组件的使用大量增加, 典型的如naive-ui, 从其文档中你能找到大量函数组件的使用, 由此可见, Vue3的函数组件确实在某种意义上有着巨大的好处. 但与之相应的, 函数组件的使用也有着一些误区.\n函数组件的应用场景 重复的模板片段, 在Vue3中, 配合JSX, 重复片段的组件提取将变得异常简单 插槽的封装, 截止本文编写, Vue插槽始终没有好的编辑器支持(指VS Code, 没用过WebStorm), 但通过将插槽封装成Props的方式, 你将得到具有类型支持的组件. 你可以在naive-ui中看到许多这种写法. 毕竟现在插槽就是一个值为函数组件的对象, 封装起来毫无压力 对状态组件的强化, setup script一个很好的地方在于省去了很多的模板代码, 代码短了自然会好读好写一些, 但不好的地方的就是糟糕的TypeScript支持了, 在包含类型的时候volar插件可能会错误解析你的代码, 而#4294这个issue估计是有生之年系列了. 在某些情况下, 你可以考虑使用函数组件来强化你的状态组件. 函数组件的Props并不需要像defineProps那样从类型声明编译, 你可以直接使用各种复杂类型就像是在一般的TS中那样 使用函数组件的注意事项 虽然你可以对组件的插槽按Props的方式封装, 但如果你不是从头开始写一个组件库, 而是在现有组件的基础上操作, 这样的做法可能并不好, 因为你改变了原有的API 当你使用函数组件对状态组件进行包裹的时候, 你需要注意, 状态组件(子组件)的交互应当避免对函数组件(父组件)Props的操作, 函数组件Props更新将造成整个子树的更新, 这可能会导致你的组件卡成PPT 虽然本文拿naive-ui举例, 但我还是觉得element-plus好用\n","permalink":"https://blog.xuhui.dev/posts/vue-functional-component/","summary":"在Vue3中, 函数组件得到了史诗级加强, 具体表现有二\n写法简化, 使用便利性大大增强 随处可用的h, 插槽改版, 适用范围更加宽广 因此在Vue3下, 可以看到的是函数组件的使用大量增加, 典型的如naive-ui, 从其文档中你能找到大量函数组件的使用, 由此可见, Vue3的函数组件确实在某种意义上有着巨大的好处. 但与之相应的, 函数组件的使用也有着一些误区.\n函数组件的应用场景 重复的模板片段, 在Vue3中, 配合JSX, 重复片段的组件提取将变得异常简单 插槽的封装, 截止本文编写, Vue插槽始终没有好的编辑器支持(指VS Code, 没用过WebStorm), 但通过将插槽封装成Props的方式, 你将得到具有类型支持的组件. 你可以在naive-ui中看到许多这种写法. 毕竟现在插槽就是一个值为函数组件的对象, 封装起来毫无压力 对状态组件的强化, setup script一个很好的地方在于省去了很多的模板代码, 代码短了自然会好读好写一些, 但不好的地方的就是糟糕的TypeScript支持了, 在包含类型的时候volar插件可能会错误解析你的代码, 而#4294这个issue估计是有生之年系列了. 在某些情况下, 你可以考虑使用函数组件来强化你的状态组件. 函数组件的Props并不需要像defineProps那样从类型声明编译, 你可以直接使用各种复杂类型就像是在一般的TS中那样 使用函数组件的注意事项 虽然你可以对组件的插槽按Props的方式封装, 但如果你不是从头开始写一个组件库, 而是在现有组件的基础上操作, 这样的做法可能并不好, 因为你改变了原有的API 当你使用函数组件对状态组件进行包裹的时候, 你需要注意, 状态组件(子组件)的交互应当避免对函数组件(父组件)Props的操作, 函数组件Props更新将造成整个子树的更新, 这可能会导致你的组件卡成PPT 虽然本文拿naive-ui举例, 但我还是觉得element-plus好用","title":"Vue Functional Component"}]