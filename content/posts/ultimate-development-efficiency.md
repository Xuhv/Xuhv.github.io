---
title: "极致的开发效率"
date: 2022-10-03T20:22:00+08:00
showToc: true
categories: no
series:
  - "Development Efficiency"
---

只是瞎扯下我认为的极致开发效率, 能提升效率的前提是前端使用TS, 连TS都没有谈个蛋效率

### [前端 & 后端] 代码生成, GraphQl和Restful API

能生成的代码尽量让他生成, 谁他妈吃饱了去写那么多代码啊. 

#### Restful API

后端API编写的时候, Swagger应当注明返回值类型, 使用代码生成工具, 从openapi文档生成出需要到客户端请求代码. 这一条主要方便的是前端, 后端工作量不变(我他妈还真见过swagger没有返回类型的后端, 你会写个几把后端, 至于swagger跟实际对不上的, 我也无fuck说).

#### GraphQL

面对各种毫无卵用的查询, 后端和前端都苦不堪言, 那么用GraphQL. 后端定义写好数据源, 后面就可以不用管啦. 前端要啥取啥, GraphQL类型支持大大滴好, 写俩GraphQL文件, 继续生成代码, 谁他妈没事写那么多代码写着玩啊?

#### GraphQl和Restful API混用

Restful API一个好处是自由, 与其他内容集成也好操作, 好改动, 我觉着写操作和敏感一些的操作都通过一般的控制器来写就行了, 记录日志, 添加各种离谱操作也方便, 用id查询单个对象也用这个, 简单. 而读操作, 特指查一组数据, 各种不胜其烦的查询条件就是从这来的, 用GraphQL.

当然, 这会产生一些问题:
1. 两种请求混用, 生成的代码中会包含两套类型定义, 不过我觉得问题不大, 可以忽略.
2. 你得写两套异常处理

### [前端: Vue] SFC 和 TSX

到了Vue3, TS支持其实已经有很大提升了, 奈何, 模板语法跟TS就是天生不对付, 用着用着你就发现不对劲了. 而TSX呢, 现在Vue3的组件库已经有很多是用TSX写的了, 但到了日常开发, 写业务的时候问题又来了, 几乎所有Vue生态都是围绕SFC来的, 用TSX就放弃了许多, 比如[antfu](https://github.com/antfu)自动引入组件的unplugin插件(当然, 用TSX也必然有收获, 比如`clinyong.vscode-css-modules`这个插件, 比如你可以摆脱`volar`给你的旧电脑减减负).

那么我的建议是, 大部分组件使用TSX编写, 需要的组件在全局注册, 手动添加类型支持, 需要写大量插槽的组件使用SFC编写, 一般来说我们的组件不会出现有大量插槽的情况, 真出现了, 那说明这部分设计可能有问题了. 需要注意的是一个很尴尬的情况是TSX文件中引入SFC组件是没有正确的类型提示的, 毕竟全局的类型声明是给写死了的, 只是`volar`给SFC提供了特殊支持, 也就是说, 我们的SFC组件不应该有复杂的props(最好没有, 或者干脆就不被其他组件调用), 那么情况很明了了, 我们的SFC应当是某一部分的入口文件, 由于种种原因无法避免地聚合了许多组件和逻辑, 才有了一大堆该死的的插槽.
