<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>false on xuhui</title>
    <link>https://blog.xuhui.dev/series/false/</link>
    <description>Recent content in false on xuhui</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 14 Oct 2022 20:49:00 +0800</lastBuildDate><atom:link href="https://blog.xuhui.dev/series/false/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Web Component</title>
      <link>https://blog.xuhui.dev/posts/web-component/</link>
      <pubDate>Fri, 14 Oct 2022 20:49:00 +0800</pubDate>
      
      <guid>https://blog.xuhui.dev/posts/web-component/</guid>
      <description>琢磨了下Web Component, 感觉就是还不太好用
跟现有的视图库相比，自定义元素并不方便，一些构建web components的库对其进行了封装，然而封装后的api又对不齐了，到头来还是距离原生开发有距离
这一点也不知道是该说好还是不好，web component这边对于事件并没有额外的关心，你就按照Web API去做就是了，假如说需要封装一个自己的input，那么在输入的时候就自行dispatchEvent(new InputEvent(&#39;input&#39;, {...}))也就行了，然而问题是，习惯了vue、react的我们怎么可能还这么写，甚至可能都不知道还有这API。。vue的事件似乎更好用一些，react直接传回调更是神之设计。不过问题倒也不大，熟悉下原来不常用的API, 就跟写原生js一样。
这个应该最容易发现，我们在用现有的视图库时，props管他啥类型，直接塞到模板/JSX上，但在html里，嗯，老实用字符串吧，复杂数据还得用js去设置。
样式的问题，现在的编辑器，直接在ts/js文件里用字符串写css没提示啊，单独起一个文件吧，还得过一道编译，麻烦。
编辑器对自定义元素的支持拉胯，虽然几年前vscode就已经支持了custom data，但在我不长的体验时间里失灵有点频繁。</description>
    </item>
    
    <item>
      <title>Fucking Javascript</title>
      <link>https://blog.xuhui.dev/posts/fucking-javascript/</link>
      <pubDate>Thu, 13 Oct 2022 23:56:23 +0800</pubDate>
      
      <guid>https://blog.xuhui.dev/posts/fucking-javascript/</guid>
      <description>迷惑的unrefined 无意中看到了某项目的代码中用了void 0，不是很懂为啥不用undefined，遂百度，得到的回答是undefined不是保留字，只是一个全局变量
一敲， 还真是这样
哦，怕全局变量被改了嘛，情有可原， 然后他妈的就这样了
你说你闹哪样？</description>
    </item>
    
    <item>
      <title>关于深拷贝</title>
      <link>https://blog.xuhui.dev/posts/about-deepcopy/</link>
      <pubDate>Wed, 05 Oct 2022 00:39:52 +0800</pubDate>
      
      <guid>https://blog.xuhui.dev/posts/about-deepcopy/</guid>
      <description>原来遇到要深拷贝这种操作我一般就JSON.stingify然后JSON.parse了(为啥不用lodash呢, 我也没个很好的理由, 可能是看见项目package.json里没这个包也不好自己加得?)
后来lodash就真香了, 但某次看着引入的函数, 我就在想这种递归的方式比用JSON好在哪里, 函数没了? 我只是用来拷贝数据, 不存在这个问题啊; 循环依赖, 什么大聪明非得干出循环依赖的数据来? 至于别的, 等等, JSON和JS对象差别在哪? JS对象的类型定义应该是Record&amp;lt;string | number | Symbol, any&amp;gt;, 嗯Symbol类型肯定是炸了, 不过谁数据里要这玩意儿啊, 再想想别的. 嗯, JSON就对象, 数组, 字符串, 数字, 布尔和null几种类型, 但JS常用的还有undefined, Date也用来表示数据, undefined我知道, 序列化后就没得咯, 很棒的特性, 表单置空用这个就不会发额外字段到后端了, Date呢, 试了下, 会变成ISO格式的字符串, 原来如此. 另外一搜索, 发现还有NaN, Infinity, -Infinity也会被序列化成null.
另外前阵子出了个structuredClone的API, 用这个的话更好, lodash可删(防抖节流? 嗯, 先继续用着吧, 正经人谁手写这玩意儿啊). 一看兼容性, 好家伙Chrome 98, Firefox 94, Node.Js 17, 这谁顶得住, 但这个see also就很妙了, 对啊, 这玩意api虽然有些许不同, 但不还是个深拷贝吗, polyfill下就得了, cloneDeep可删.</description>
    </item>
    
  </channel>
</rss>
