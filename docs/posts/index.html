<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | xuhui</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - xuhui">
<meta name="author" content="xuhui">
<link rel="canonical" href="https://blog.xuhui.dev/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.af94436b6b7f014090c8ba4bb0f636854232407cdf19ee6105642567e42b0e39.css" integrity="sha256-r5RDa2t/AUCQyLpLsPY2hUIyQHzfGe5hBWQlZ&#43;QrDjk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.xuhui.dev/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.xuhui.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.xuhui.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.xuhui.dev/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.xuhui.dev/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://blog.xuhui.dev/posts/index.xml">
<link rel="alternate" hreflang="zh" href="https://blog.xuhui.dev/posts/">
<link rel="alternate" hreflang="en" href="https://blog.xuhui.dev/en/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="xuhui&#39;s pages: a web developer." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://blog.xuhui.dev/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="xuhui&#39;s pages: a web developer."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.xuhui.dev/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.xuhui.dev/" accesskey="h" title="xuhui (Alt + H)">xuhui</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://blog.xuhui.dev/en/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.xuhui.dev/categories" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://blog.xuhui.dev/series/" title="专栏">
                    <span>专栏</span>
                </a>
            </li>
            <li>
                <a href="https://blog.xuhui.dev/index.xml" title="Rss">
                    <span>Rss</span>
                </a>
            </li>
            <li>
                <a href="https://blog.xuhui.dev/search" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://blog.xuhui.dev/">主页</a></div>
  <h1>
    Posts
    <a href="index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Web Component
    </h2>
  </header>
  <div class="entry-content">
    <p>琢磨了下Web Component, 感觉就是还不太好用
跟现有的视图库相比，自定义元素并不方便，一些构建web components的库对其进行了封装，然而封装后的api又对不齐了，到头来还是距离原生开发有距离
这一点也不知道是该说好还是不好，web component这边对于事件并没有额外的关心，你就按照Web API去做就是了，假如说需要封装一个自己的input，那么在输入的时候就自行dispatchEvent(new InputEvent(&#39;input&#39;, {...}))也就行了，然而问题是，习惯了vue、react的我们怎么可能还这么写，甚至可能都不知道还有这API。。vue的事件似乎更好用一些，react直接传回调更是神之设计。不过问题倒也不大，熟悉下原来不常用的API, 就跟写原生js一样。
这个应该最容易发现，我们在用现有的视图库时，props管他啥类型，直接塞到模板/JSX上，但在html里，嗯，老实用字符串吧，复杂数据还得用js去设置。
样式的问题，现在的编辑器，直接在ts/js文件里用字符串写css没提示啊，单独起一个文件吧，还得过一道编译，麻烦。
编辑器对自定义元素的支持拉胯，虽然几年前vscode就已经支持了custom data，但在我不长的体验时间里失灵有点频繁。</p>
  </div>
  <footer class="entry-footer"><span title='2022-10-14 20:49:00 +0800 CST'>十月 14, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;xuhui</footer>
  <a class="entry-link" aria-label="post link to Web Component" href="https://blog.xuhui.dev/posts/web-component/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Fucking Javascript
    </h2>
  </header>
  <div class="entry-content">
    <p>迷惑的unrefined 无意中看到了某项目的代码中用了void 0，不是很懂为啥不用undefined，遂百度，得到的回答是undefined不是保留字，只是一个全局变量
一敲， 还真是这样
哦，怕全局变量被改了嘛，情有可原， 然后他妈的就这样了
你说你闹哪样？</p>
  </div>
  <footer class="entry-footer"><span title='2022-10-13 23:56:23 +0800 CST'>十月 13, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;xuhui</footer>
  <a class="entry-link" aria-label="post link to Fucking Javascript" href="https://blog.xuhui.dev/posts/fucking-javascript/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>博客: 记录而不是分享
    </h2>
  </header>
  <div class="entry-content">
    <p>以前也尝试写过博文, 但总是没几篇就放弃了, 写到最后总是结果往往是不想写了, 写了又没人看那还写啥, 况且也没那么多值得写的东西, 互联网上垃圾以及够多了, 有时候把号都删了…
知乎上, B站上有许多没有多少阅读/观看的文章视频, 其中许多还质量极高, 相反, 某些个流量极高的文章视频就说是垃圾也不为过, 我不懂为什么会这样, 是叶公好龙的小白和那些没有自己思考判断的人才是流量的主要来源吗? 或许吧, 我看短视频啥的时候也从来不带脑子.
但这些创作者又为什么坚持呢? 而除了这些较高水平但没有流量的作品, 其实偶尔还能在网上看到一些水平一般内容无趣也没啥流量的作品, 如果不是作品刚发出来或者我偶尔点进谁的主页, 根本就发现不了这些作品这些作者的存在, 这样作者们又是为了什么坚持呢?
似乎哪个群的网友分享的一个抖音视频点醒了我. 也不记得视频是讲什么的了, 大概率是某个衣着暴露/猎奇的的女的扭来扭去吧, 他们总爱看这些(我不是, 我没有!). 看到最后, 一个很有穿透力的声音配着logo就出来了: 抖音! 嗯, 我记得之前我手机里还有抖音的时候, 好像是&#34;抖音, 记录美好生活&#34;来着.
是了, 当我这次开始写博文的时候, 我终于想通了, 是记录. 是记录而不是分享, 那些沉没在数据库中的内容或许有很多都是如此, 生活可能并不美好, 就像某些平台上的技术文章其实毫无技术含量. 但对于经历者, 这还是有意义的, 生活需要仪式感, 于是他们记录下生活, 学习需要正反馈, 那么便将其记录下来吧, 或许在别人眼中不值一提, 但也真真切切是自己所经历过的. 随便打开个博文网站, 里面大部分的内容是重复又简单的, 但想起来, 自己也曾学过这些, 但回头看去, 却仿佛自己什么也没留下, 就像我二十年的生活也没留下什么记忆一样, 或许我也该记录一下.
至于有没有人看? 去他妈的, 一味追求流量的那叫营销号.</p>
  </div>
  <footer class="entry-footer"><span title='2022-10-05 09:50:11 +0800 CST'>十月 5, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;xuhui</footer>
  <a class="entry-link" aria-label="post link to 博客: 记录而不是分享" href="https://blog.xuhui.dev/posts/record-rather-than-share/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>关于深拷贝
    </h2>
  </header>
  <div class="entry-content">
    <p>原来遇到要深拷贝这种操作我一般就JSON.stingify然后JSON.parse了(为啥不用lodash呢, 我也没个很好的理由, 可能是看见项目package.json里没这个包也不好自己加得?)
后来lodash就真香了, 但某次看着引入的函数, 我就在想这种递归的方式比用JSON好在哪里, 函数没了? 我只是用来拷贝数据, 不存在这个问题啊; 循环依赖, 什么大聪明非得干出循环依赖的数据来? 至于别的, 等等, JSON和JS对象差别在哪? JS对象的类型定义应该是Record&lt;string | number | Symbol, any&gt;, 嗯Symbol类型肯定是炸了, 不过谁数据里要这玩意儿啊, 再想想别的. 嗯, JSON就对象, 数组, 字符串, 数字, 布尔和null几种类型, 但JS常用的还有undefined, Date也用来表示数据, undefined我知道, 序列化后就没得咯, 很棒的特性, 表单置空用这个就不会发额外字段到后端了, Date呢, 试了下, 会变成ISO格式的字符串, 原来如此. 另外一搜索, 发现还有NaN, Infinity, -Infinity也会被序列化成null.
另外前阵子出了个structuredClone的API, 用这个的话更好, lodash可删(防抖节流? 嗯, 先继续用着吧, 正经人谁手写这玩意儿啊). 一看兼容性, 好家伙Chrome 98, Firefox 94, Node.Js 17, 这谁顶得住, 但这个see also就很妙了, 对啊, 这玩意api虽然有些许不同, 但不还是个深拷贝吗, polyfill下就得了, cloneDeep可删.</p>
  </div>
  <footer class="entry-footer"><span title='2022-10-05 00:39:52 +0800 CST'>十月 5, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;xuhui</footer>
  <a class="entry-link" aria-label="post link to 关于深拷贝" href="https://blog.xuhui.dev/posts/about-deepcopy/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>使用路由分割APP
    </h2>
  </header>
  <div class="entry-content">
    <p>我很烦的一件事就是在某些屎山项目里找代码, 即使编辑器的辅助功能已经非常强大多花不了多少时间, 但真遇到了还是本能得厌恶. 典型的有
无数个路由写尼玛一个文件里
一个SFC写上两千行
整个项目都anyscript, 直接把编辑器跳转功能干废
这里只针对 1. 提出一个我觉得比较合理的写法: “模块化”, 使用路由分割应用逻辑
所谓&#34;模块化&#34;, 其实就是把路由表按组分拆到页面去, 比如我的应用有如下的大几十个页面
系统管理-系统设置 系统管理-在线设置 系统管理-组织设置 项目管理-项目 项目管理-人员 ... 那我们就不应当把他们全平铺在router.ts文件中, 而是针对&#34;系统管理&#34;, “项目管理&#34;等模块, 在其目录下新建一个路由表, 这样查看代码的时候也方便知道那个页面是什么玩意儿, 写在哪的. (什么, 你跟我说你相关逻辑散在views, components各个文件夹? mdzz, 这个话题针对就是你们这种人才.) 似乎计算机组成原理课程上, 有个局部性的概念, 这玩意儿也类似的, 可能要常用的代码, 不应该放近点吗?
这样写还有个好处就是控制编译出的代码文件, 通过这种方式, 我们可以很轻易地通过每个模块的路由表来控制chunk, 需要代码分割, 异步加载这个路由表呗, 如果你的应用权限是按模块来的, 那直接鉴权都一起做了, 都不需要的话那就直接插到router.ts就好了, 某个页面实在大到咬人, 那就在路由表里把这个页面也给异步加载了呗. 至于为啥不全部异步, 嗯, 当然可以, 如果你愿意.</p>
  </div>
  <footer class="entry-footer"><span title='2022-10-04 04:27:23 +0800 CST'>十月 4, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;xuhui</footer>
  <a class="entry-link" aria-label="post link to 使用路由分割APP" href="https://blog.xuhui.dev/posts/use-router-to-split-app/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Overridable Component Like MUI in Vue
    </h2>
  </header>
  <div class="entry-content">
    <p>在React的组件库MUI中, 有一个看上去就叼到爆的功能OverridableComponent, 在我初学TS那阵子, 那简直就是神迹, 后来对TS逐渐熟悉了看了下源码也就释然了, 再后来一次还尝试写过一个Vue版本.
本来看懂了原实现, 以为这个移植就是手到擒来, 然而事实上port到Vue还是有点麻烦, 主要问题有
React.ElementType这个类型在Vue中没有等价的东西, 我定义的这个ComponentTsx也没考虑其他情况, 就刚好这里能用而已 从Vue组件里获取$props类型的这个方式有点诡异, 事实上, 这样获取到的也不止props, 还有事件. 有时候我就在想Vue的这个事件的设计是不是真的失败. 感觉就是增加了一个毫无卵用的API 而且这段代码也就能拿来练练手了, 由于Vue函数组件没状态, 容易搞出性能问题, 状态组件的props需要一个个去定义, 真想实现一个能用的OverridableComponent我还真没办法.</p>
  </div>
  <footer class="entry-footer"><span title='2022-10-03 23:38:08 +0800 CST'>十月 3, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;xuhui</footer>
  <a class="entry-link" aria-label="post link to Overridable Component Like MUI in Vue" href="https://blog.xuhui.dev/posts/overridable-component-like-mui-in-vue/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>极致的开发效率
    </h2>
  </header>
  <div class="entry-content">
    <p>只是瞎扯下我认为的极致开发效率, 能提升效率的前提是前端使用TS, 连TS都没有谈个蛋效率
[前端 &amp; 后端] 代码生成, GraphQl和Restful API 能生成的代码尽量让他生成, 谁他妈吃饱了去写那么多代码啊.
Restful API 后端API编写的时候, Swagger应当注明返回值类型, 使用代码生成工具, 从openapi文档生成出需要到客户端请求代码. 这一条主要方便的是前端, 后端工作量不变(我他妈还真见过swagger没有返回类型的后端, 你会写个几把后端, 至于swagger跟实际对不上的, 我也无fuck说).
GraphQL 面对各种毫无卵用的查询, 后端和前端都苦不堪言, 那么用GraphQL. 后端定义写好数据源, 后面就可以不用管啦. 前端要啥取啥, GraphQL类型支持大大滴好, 写俩GraphQL文件, 继续生成代码, 谁他妈没事写那么多代码写着玩啊?
GraphQl和Restful API混用 Restful API一个好处是自由, 与其他内容集成也好操作, 好改动, 我觉着写操作和敏感一些的操作都通过一般的控制器来写就行了, 记录日志, 添加各种离谱操作也方便, 用id查询单个对象也用这个, 简单. 而读操作, 特指查一组数据, 各种不胜其烦的查询条件就是从这来的, 用GraphQL.
当然, 这会产生一些问题:
两种请求混用, 生成的代码中会包含两套类型定义, 不过我觉得问题不大, 可以忽略. 你得写两套异常处理 [前端: Vue] SFC 和 TSX 到了Vue3, TS支持其实已经有很大提升了, 奈何, 模板语法跟TS就是天生不对付, 用着用着你就发现不对劲了. 而TSX呢, 现在Vue3的组件库已经有很多是用TSX写的了, 但到了日常开发, 写业务的时候问题又来了, 几乎所有Vue生态都是围绕SFC来的, 用TSX就放弃了许多, 比如antfu自动引入组件的unplugin插件(当然, 用TSX也必然有收获, 比如clinyong....</p>
  </div>
  <footer class="entry-footer"><span title='2022-10-03 20:22:00 +0800 CST'>十月 3, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;xuhui</footer>
  <a class="entry-link" aria-label="post link to 极致的开发效率" href="https://blog.xuhui.dev/posts/ultimate-development-efficiency/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Vue Functional Component
    </h2>
  </header>
  <div class="entry-content">
    <p>在Vue3中, 函数组件得到了史诗级加强, 具体表现有二
写法简化, 使用便利性大大增强 随处可用的h, 插槽改版, 适用范围更加宽广 因此在Vue3下, 可以看到的是函数组件的使用大量增加, 典型的如naive-ui, 从其文档中你能找到大量函数组件的使用, 由此可见, Vue3的函数组件确实在某种意义上有着巨大的好处. 但与之相应的, 函数组件的使用也有着一些误区.
函数组件的应用场景 重复的模板片段, 在Vue3中, 配合JSX, 重复片段的组件提取将变得异常简单 插槽的封装, 截止本文编写, Vue插槽始终没有好的编辑器支持(指VS Code, 没用过WebStorm), 但通过将插槽封装成Props的方式, 你将得到具有类型支持的组件. 你可以在naive-ui中看到许多这种写法. 毕竟现在插槽就是一个值为函数组件的对象, 封装起来毫无压力 对状态组件的强化, setup script一个很好的地方在于省去了很多的模板代码, 代码短了自然会好读好写一些, 但不好的地方的就是糟糕的TypeScript支持了, 在包含类型的时候volar插件可能会错误解析你的代码, 而#4294这个issue估计是有生之年系列了. 在某些情况下, 你可以考虑使用函数组件来强化你的状态组件. 函数组件的Props并不需要像defineProps那样从类型声明编译, 你可以直接使用各种复杂类型就像是在一般的TS中那样 使用函数组件的注意事项 虽然你可以对组件的插槽按Props的方式封装, 但如果你不是从头开始写一个组件库, 而是在现有组件的基础上操作, 这样的做法可能并不好, 因为你改变了原有的API 当你使用函数组件对状态组件进行包裹的时候, 你需要注意, 状态组件(子组件)的交互应当避免对函数组件(父组件)Props的操作, 函数组件Props更新将造成整个子树的更新, 这可能会导致你的组件卡成PPT 虽然本文拿naive-ui举例, 但我还是觉得element-plus好用</p>
  </div>
  <footer class="entry-footer"><span title='2022-10-03 15:55:26 +0800 CST'>十月 3, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;xuhui</footer>
  <a class="entry-link" aria-label="post link to Vue Functional Component" href="https://blog.xuhui.dev/posts/vue-functional-component/"></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://blog.xuhui.dev/">xuhui</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span>View<span id="busuanzi_value_site_pv"></span>times</span>
</footer>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
