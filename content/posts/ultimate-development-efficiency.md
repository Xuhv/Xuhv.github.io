---
title: "极致的开发效率"
date: 2022-11-06
showToc: true
categories: no
series:
  - "Development Efficiency"
---

只是瞎扯下我认为的极致开发效率, 能提升效率的前提是前端使用TS, 连TS都没有谈个蛋效率

### [后端 & 前端] 登录认证

这玩意还是得用现成的方案, 尤其涉及到多系统统一登陆SSO的时候, 自己造轮子简直脑子有屎, 在上家公司有幸见这群蛇皮造过一次, 说实话, 没有金刚钻就别揽瓷器活. 

但现有的一个问题是, 现在开发的时候动则前后端分离, 说实话给认证授权带来了不小麻烦, 比如OIDC令牌流, 这他妈frontend channel跟backend channel一分开, 开发时跨域跨站挣得我脑瓜子嗡嗡的. 又比如Blazor Server, 此前我觉得这个服务器渲染方案几乎完美了, 然后猛地发现: 卧槽, signalR, HttpContext拿不到的干活. 于是, 当这些情况下我们必须引入额外的配置是甚至是依赖来解决这些新生的问题, 但相比瞎几把写认证系统, 稳妥, 方便到不知哪去了.

### [前端 & 后端] 代码生成, GraphQl和Restful API

能生成的代码尽量让他生成, 谁他妈吃饱了去写那么多代码啊. 

#### Restful API

后端API编写的时候, Swagger应当注明返回值类型, 使用代码生成工具, 从openapi文档生成出需要到客户端请求代码. 这一条主要方便的是前端, 后端工作量不变(我他妈还真见过swagger没有返回类型的后端, 你会写个几把后端, 至于swagger跟实际对不上的, 我也无fuck说).

#### GraphQL

面对各种毫无卵用的查询, 后端和前端都苦不堪言, 那么用GraphQL. 后端定义写好数据源, 后面就可以不用管啦. 前端要啥取啥, GraphQL类型支持大大滴好, 写俩GraphQL文件, 继续生成代码, 谁他妈没事写那么多代码写着玩啊?

#### GraphQl和Restful API混用

Restful API一个好处是自由, 与其他内容集成也好操作, 好改动, 我觉着写操作和敏感一些的操作都通过一般的控制器来写就行了, 记录日志, 添加各种离谱操作也方便. 而读操作, 各种不胜其烦的查询条件就是从这来的, 用GraphQL.

当然, 这会产生一些问题:
1. 两种请求混用, 生成的代码中会包含两套类型定义, 不过我觉得问题不大, 在后端api设计合理的情况下, 可以忽略.
2. 前端得写两套异常处理

### [前端: Vue] SFC 和 TSX

到了Vue3, TS支持其实已经有很大提升了, 奈何, 模板语法跟TS就是天生不对付, 用着用着你就发现不对劲了. 而TSX呢, 现在Vue3的组件库已经有很多是用TSX写的了, 但到了日常开发, 写业务的时候问题又来了, 几乎所有Vue生态都是围绕SFC来的, 用TSX就放弃了许多, 比如[antfu](https://github.com/antfu)自动引入组件的unplugin插件(当然, 用TSX也必然有收获, 比如`clinyong.vscode-css-modules`这个插件, 比如你可以摆脱`volar`给你的旧电脑减减负).

那么我的建议是, 大部分组件使用TSX编写, 需要的组件在全局注册, 手动添加类型支持, 需要写大量插槽的组件使用SFC编写, 一般来说我们的组件不会出现有大量插槽的情况, 真出现了, 那说明这部分设计可能有问题了. 需要注意的是一个很尴尬的情况是TSX文件中引入SFC组件是没有正确的类型提示的, 毕竟全局的类型声明是给写死了的, 只是`volar`给SFC提供了特殊支持, 也就是说, 我们的SFC组件不应该有复杂的props(最好没有, 或者干脆就不被其他组件调用), 那么情况很明了了, 我们的SFC应当是某一部分的入口文件, 由于种种原因无法避免地聚合了许多组件和逻辑, 才有了一大堆该死的的插槽.
